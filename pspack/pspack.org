#+title: pspack
#+property: header-args :tangle t :mkdirp t :results no :eval never
#+OPTIONS: _:nil
#+auto_tangle: t

* Headers
#+begin_src emacs-lisp :tangle pspack.el
  ;;; pspack/pspack.el --- common pspmacs utils -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;;
  ;; Custom variables, functions, faces for pspmacs config.
  ;;
  ;;; Code:
  (defgroup pspack nil
    "Functions and variables used by pspmacs, bundled into a package."
    :group 'pspack)
#+end_src

#+begin_src emacs-lisp :tangle vars.el
  ;;; pspack/vars.el --- common pspmacs variables -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;;
  ;; Custom variables for pspmacs config.
  ;;
  ;;; Code:
#+end_src

#+begin_src emacs-lisp :tangle func.el
  ;;; pspack/func.el --- common pspmacs functions -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;;
  ;; Functions used by pspmacs configuration
  ;;
  ;;; Code:
#+end_src

* Packaging
** Move url cookies to =XDG=
#+begin_src emacs-lisp :tangle vars.el
  (require 'pspmacs/xdg)
#+end_src

** Install git clone
In Emacs-29, this is obviated.

#+begin_src emacs-lisp :tangle func.el
  (require 'pspmacs/crooked)
  (defun pspmacs/install-git-clone (melpa-style-recipe
                                    &optional
                                    no-clone
                                    no-build
                                    cause interactive
                                    &rest kwargs)
    "Install packages by git-cloning its source code.

  If the variable `pspmacs/install-git-clones' is nil, do nothing.
  If package-manager is `straight', Simply use it, passing optional arguments
  NO-CLONE NO-BUILD CAUSE INTERACTIVE to `straight-use-package'. Else, clone
  the MELPA-STYLE-RECIPE, compile it. If kwargs :force is non nil,
  force installation despite the value of `pspmacs/install-git-clones'"
    (if (or pspmacs/install-git-clones (plist-get kwargs :force))
        (if (string= pspmacs/package-manager "straight")
            (straight-use-package melpa-style-recipe
                                  no-clone
                                  no-build
                                  cause
                                  interactive)
          (pspmacs/crooked-git-clone melpa-style-recipe))
      (message "Not cloning %s because `pspmacs/install-clones' is nil"
               melpa-style-recipe)))
#+end_src

* Update PSPmacs
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs--call-shell (program args &optional on-fail)
      "Call shell command from function.

  Exceute PROGRAM in shell with ARGS.
  On failure execute ON-FAIL if given.
  Return STDOUT as a string
  Copied and maybe modufied form module pspmacs-ci-cd."
      (message "Executing: %s args: %s" program args)
      (with-temp-buffer
        (let ((exit-code (apply 'call-process
                                `(,program nil ,(current-buffer) nil ,@args))))
          (unless (eq 0 exit-code)
            (when on-fail
              (switch-to-buffer (current-buffer))
              (eval on-fail)))
          (replace-regexp-in-string "\n$" "" (buffer-string)))))

  (defun pspmacs/git-rebase ()
    "Synchronize by rebasing locally cloned worktree/git on remote git."
    (interactive)
    (let ((default-directory user-emacs-directory))
      (pspmacs--call-shell "git" '("fetch" "origin"))
      (pspmacs--call-shell "git" '("rebase")))
    (message "done."))
#+end_src

* Home-splash
- Home splash screen customizations
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/home-splash-before-hook nil
    "Run before switching to pspmacs/home-splash."
    :group 'pspack
    :type '(hook :tag "Before home-splash"))

  (defcustom pspmacs/home-splash-hook nil
    "Run after switching to pspmacs/home-splash."
    :group 'pspack
    :type '(hook :tag "After home-splash"))
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/home-splash-before ()
    "run functions before switching to splash buffer."
      (dashboard-refresh-buffer)
      (run-hooks 'pspmacs/home-splash-before-hook))

  (defun pspmacs/home-splash ()
    "Visit home screen."
    (interactive)
    (progn
      (pspmacs/home-splash-before)
      (setq-default default-directory "~/")
      (run-hooks 'pspmacs/home-splash-hook)))

#+end_src

* Highlighted tags
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/hl-tag-faces
    '(("FAIL"  . "#ff3f3f")
      ("FIXME" . "#ff6f3f")
      ("TEMP"  . "#ff9f3f")
      ("HACK"  . "#ffcf3f")
      ("TODO"  . "#ffff3f")
      ("LAZY"  . "#e7ff3f")
      ("WAIT"  . "#cfff3f")
      ("NEXT"  . "#9fff3f")
      ("ALGO"  . "#6fff3f")
      ("PROG"  . "#3fff3f")
      ("TEST"  . "#3fe757")
      ("ACTS"  . "#3fcf6f")
      ("SENT"  . "#3f9f9f")
      ("OKAY"  . "#3f6fcf")
      ("DONE"  . "#3f3fff")
      ("NOTE"  . "#ffcf6f")
      ("XXXX"  . "#ff9f9f")
      ("DONT"  . "#ff6fcf")
      ("CANT"  . "#ff3fff"))
    "Highlight colors for TODO tags."
    :group 'pspack
    :type '(repeat (cons (string :tag "hl-tag") (string :tag "color"))))
#+end_src

* Prettify data
- Prettify modes with emoji
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/pretty-alist
    '(("code" . (("\\n" . ?⏎)
                 ("\\t" . ?↹)))
      ("lisp" . (("lambda" . ?λ)))
      ("org" . (("#+setupfile" . ?🛒)
                ("#+author" . ?🖋)
                ("#+begin_note" . ?📋)
                ("#+end_note" . ?⏎)
                ("#+begin_example" . ?🥚)
                ("#+end_example" . ?⏎)
                ("#+begin_src" . ?🤖)
                ("#+end_src" . ?⏎)
                ("#+begin_tip" . ?💡)
                ("#+end_tip" . ?👍)
                ("#+begin_warn" . ?⚠)
                ("#+end_warn" . ?⏎)
                ("#+begin_warning" . ?⚠)
                ("#+end_warning" . ?⏎)
                ("#+email" . ?✉)
                ("#+language" . ?🗣)
                ("#+options" . ?🔘)
                ("#+property" . ?⚙)
                ("#+results" . ?📜)
                ("#+startup" . ?)
                ("#+html_head" . ?)
                ("#+attr_latex:" . ?🖺)
                ("#+title" . ?§)
                (":properties:" . ?)
                (":end:" . ?⏎)
                ("tangle" . ?🔗)
                ("shebang" . ?⌘)
                ("[x]" . ?✔)
                ("[ ]" . ?❌)
                ("[-]" . ?⏳)))
      ("python" . (("->" . ?⇒)))
      ("rust" . ()))
    "Pretty symbols."
    :group 'pspack
    :type '(repeat (cons
                    (string :tag "major-mode")
                    (repeat (cons (string :tag "to prettify")
                                  (integer :tag "Pretty symbol ORD"))))))
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/mode-prettify (sub-modes)
    "Apply pretiffy mode alist according to active-mode.

  Load prettify-symbols from Each of SUB-MODES."
    (progn
      (setq
       prettify-symbols-alist
       (mapcan (lambda (x)
                 (list x `(,(upcase (car x)) . ,(cdr x))))
               (apply #'append
                      (mapcar
                       (lambda (y)
                         (cdr (assoc y pspmacs/pretty-alist)))
                       sub-modes))))
      (prettify-symbols-mode)))
#+end_src

*** Prettify ESS/R
#+begin_src emacs-lisp :tangle vars.el
  (defface pspmacs/r-namespace-face '((t (:foreground "#9f7fff")))
    "R package namespace."
    :group 'pspack)

  (defface pspmacs/r-name-obj-face '((t (:foreground "#7f97af")))
    "Object referred from R package namespace."
    :group 'pspack)

  (defface pspmacs/r-list-face '((t (:foreground "#bf8faf")))
    "R list."
    :group 'pspack)

  (defface pspmacs/r-list-obj-face '((t '(:foreground "#9fb7cf")))
    "Object referred from R list"
    :group 'pspack)

  (defcustom pspmacs/r-keywords
    '(("\\W\\(\\(\\s_\\|\\w\\|\\.\\)+\\)::"
       1 'pspmacs/r-namespace-face prepend)
      ("\\w::\\(\\(\\s_\\|\\w\\|\\.\\)+\\)"
       1 'pspmacs/r-name-obj-face prepend)
      ("\\(\\(\\s_\\|\\w\\|\\.\\)+\\)\\$\\w"
       1 'pspmacs/r-list-face prepend)
      ("\\w\\$\\(\\(\\s_\\|\\w\\|\\.\\)+\\)"
         1 'pspmacs/r-list-obj-face prepend))
    "Custom keywords to highlight in R mode"
    :group 'pspack
    :type '(repeat (list :tag "R highlight keywords")))
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prettify-R ()
    "Prettify ess-R"
    (pspmacs/mode-prettify '("code" "R")))

  (defun pspmacs/rfaces ()
    "R callable hook function"
    (font-lock-add-keywords 'R-mode pspmacs/r-keywords))
#+end_src

*** Prettify Python
#+begin_src emacs-lisp :tangle vars.el
  (defface pspmacs/pyargs-face
    '((t (:foreground "#9f7fff")))
    "Python arguments face identified as '*args' and '**kwargs'."
    :group 'pspack)

  (defface pspmacs/pyprivate-face
    '((t (:slant italic :box t)))
    "python private symbols identified as '_private'."
    :group 'pspack)

  (defface pspmacs/pydunder-face
    '((t (:slant italic :foreground "#cfff40")))
    "python dunder symbols identified as '__dunder__'."
    :group 'pspack)

  (defface pspmacs/rst-literal-face
    '((t (:box t)))
    "Restructured text literals delimited by double backquotes `\`\`True\`\``."
    :group 'pspack)

  (defcustom pspmacs/py-keywords
    '(("\\W\\(\\*\\{1,2\\}\\(\\s_\\|\\w\\|\\.\\)+\\)"
       1 'pspmacs/pyargs-face t append)
      ("\\W\\(_\\{1,2\\}\\(\\s_\\|\\w\\|\\.\\)+_\\{0,2\\}\\)"
       1 'pspmacs/pyprivate-face prepend)
      ("\\W\\(__\\(\\s_\\|\\w\\|\\.\\)+__\\)"
       1 'pspmacs/pydunder-face t)
      ("\\W\\(\\([0-9]*_?[0-9]+\\)+\\(\\.[0-9]*\\)?\\)"
       1 'font-lock-constant-face nil)
      ("\\W\\(\\([0-9]*_?[0-9]+\\)*\\(\\.[0-9]+\\)\\)"
       1 'font-lock-constant-face nil)
      (") ?\\(->\\) ?" 1 'font-lock-keyword-face nil)
      ("``\\(.*?\\)``" 1 'pspmacs/rst-literal-face prepend))
    "Custom keywords to highlight in python mode"
    :group 'pspack
    :type '(repeat (list :tag "Python highlight keywords")))
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prettify-python ()
    "Prettify python"
    (pspmacs/mode-prettify '("code" "python")))

  (defun pspmacs/pyfaces ()
    "Python keyword faces"
    (font-lock-add-keywords nil pspmacs/py-keywords))
#+end_src

*** Prettify Emacs-Lisp
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/elisp-keywords
    '(("\\W\\(\\([0-9]*_?[0-9]+\\)*\\(\\.[0-9]+\\)\\)"
       1 'font-lock-constant-face nil)
      ("\\W\\(t\\|\\nil)\\W"
       1 'font-lock-constant-face nil))
    "Custom keywords to highlight in emacs-lisp mode"
    :group 'pspack
    :type '(repeat (list :tag "emacs-lisp highlight keywords")))
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prettify-emacs-lisp ()
    "Prettify Emacs-Lisp"
    ;; (font-lock-add-keywords nil pspmacs/elisp-keywords)
      (pspmacs/mode-prettify '("code" "emacs-lisp")))
#+end_src

*** Prettify Org
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prettify-note ()
    (pspmacs/mode-prettify '("lisp" "org")))
#+end_src

*** Prettify Rust
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prettify-rust ()
    (pspmacs/mode-prettify '("code" "rust")))
#+end_src

* Set face attribute for daemon mode
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/font-height 150
    "10 x Font-height"
    :group 'pspack
    :type 'integer)
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/set-font-faces ()
    (set-face-attribute 'default nil
                        :font "Fira Code"
                        :height pspmacs/font-height)

    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch nil
                        :font "Fira Code"
                        :height pspmacs/font-height)

    ;; Set italic font face if available
    (ignore-errors
      (set-face-attribute 'italic nil
                          :font "VictorMono"
                          :slant 'italic
                          :height pspmacs/font-height)

      ;; Set the variable pitch face
      (set-face-attribute 'variable-pitch nil
                          :font "Cantarell"
                          :height pspmacs/font-height
                          :weight 'regular)))
#+end_src

* Order of pspmacs modules to load
Although =use-package-always-ensure= is set to =t=, somehow, it needs to be explicitly passed as kw ~:ensure t~ for the first time.
This behaviour is only with the builtin package manager, not with =straight.el=.

#+begin_src emacs-lisp :tangle vars.el
  (use-package yaml
    :ensure t
    :demand t)
  (use-package ht
    :demand t)
  (use-package f
    :demand t)

  (defcustom pspmacs/modules-order
    (let
        ((modules-dir
          (mapcar
           (lambda (x) (expand-file-name "modules" x)) pspmacs/worktrees)))
      (apply
       'vconcat (mapcar
                 (lambda (x) (cdr x))
                 (sort
                  (ht->alist
                  (apply
                   'ht-merge
                   (remq 'nil
                         (mapcar
                          (lambda (x)
                            (let
                                ((order-file
                                  (expand-file-name "load-order.yml" x)))
                              (if (file-readable-p order-file)
                                  (yaml-parse-string
                                   (f-read-text order-file)))))
                          modules-dir))))
                 (lambda (a b) (< (car a) (car b)))))))
    "Ordered list of pspmacs/modules to load."
    :group 'pspack
    :type '(repeat (string :tag "module-name")))
    #+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/load-modules (&optional modules-order)
    "Load modules in order.

  Load modules as defined in MODULES-ORDER.
  Defaults to the variable pspmacs/modules-order"
    (let* ((modules-order (or modules-order pspmacs/modules-order)))
      (seq-doseq (autofile modules-order nil)
        (catch 'load-success
          (dolist (work-tree pspmacs/worktrees nil)
            (let* ((lit-module
                    (expand-file-name
                     (format "modules/pspmacs-%s.org" autofile) work-tree))
                   (found (when (file-readable-p lit-module)
                            (pspmacs/load-suitable lit-module)
                            lit-module)))
              (when found (throw 'load-success lit-module))))))))
#+end_src

* Byte compile worktrees
Following function may be used to byte-compile any work-tree.
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/byte-worktree t
    "Byte compile worktrees?"
    :group 'pspack
    :type 'boolean)
#+end_src

#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/byte-compile-worktrees (&optional worktree)
    "Byte-compile directory recursively.

  Target: WORKTREE.
  Default worktree is global (`user-emacs-directory)
  This may be disabled by setting `pspmacs/byte-worktree' to nil"
    (unless (and (boundp 'no-native-compile) no-native-compile)
      (when pspmacs/byte-worktree
        (let ((worktree (or worktree user-emacs-directory)))
          (byte-recompile-directory worktree 0)))))
#+end_src

* Inferior interpreter
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/inferior-interpreter (executable)
    "Open an inferior interpreter in split window.

  Open EXECUTABLE interpreter in an inferior windows."
    (interactive)
    (let ((interpreter-window (split-window-below)))
      (select-window interpreter-window)
      (call-interactively executable)))
#+end_src

* Destroy buffer and window when user application exits
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/destroy-buffer-and-window (&optional target-buffer)
    "Destroy window and buffer after some process is done.

  If TARGET-BUFFER is supplied, it and its window is destroyed.
  Else, current buffer and window is destroyed.
  If window is the only window, it is spared"
    (let* ((used-buffer (or target-buffer (current-buffer)))
           (used-window (get-buffer-window used-buffer)))
      (when (not (one-window-p))
        (delete-window used-window))
      (kill-buffer used-buffer)))
#+end_src

* Switch to minibuffer
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (message "Minibuffer is not active")))
#+end_src

* Kill all other buffers
#+begin_src emacs-lisp :tangle func.el
(defun pspmacs/kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src

* Extend list as in python
- Extend a list with elements from an iterable.
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/extend-list (list-var elements)
    "Iterative form of ‘add-to-list’.

  Add each element from ELEMENTS to LIST-VAR.
  Return value is the new value of LIST-VAR."
    (unless (listp elements)
      (user-error "ELEMENTS must be list"))
    (dolist (elem elements)
      (add-to-list list-var elem))
    (symbol-value list-var))
#+end_src

* Conditional callback
- Add to a hook unless major mode is other than listed.
  #+begin_src emacs-lisp :tangle func.el
    (defun pspmacs/maj-cond-call (callback maj-modes)
      "Run CALLBACK unless major mode is any of MAJ-MODES.

    If MAJ-MODES is a list, `major-mode' shouldn't be in MAJ-MODES."
      (let ((maj-modes-list
             (if (listp maj-modes) maj-modes `(,maj-modes))))
        (unless (member major-mode maj-modes-list)
          (call-interactively callback))))
  #+end_src

* Theme customizations
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/modus-themes-custom-faces ()
    "Customize modus theme faces."
    (modus-themes-with-colors
      (progn
        (custom-set-faces
         ;; Add "padding" to the mode lines
         `(hl-line ((,c :slant italic)))
         `(org-document-title ((,c :foreground "#ffff9f")))
         `(font-function-name-face ((,c :foreground "#9f5f9f" :weight bold)))
         `(font-lock-comment-face ((,c :foreground "#bfdfff"
                                       :background "#003050"
                                       :slant italic)))
         `(font-lock-doc-face ((,c :foreground "#ffdfbf"
                                   :background "#503000"
                                   :slant italic)))
         `(line-number ((,c :foreground "#4f5f7f" :background "#000000")))
         `(font-lock-type-face ((,c :foreground "#ff3f5f" :weight bold)))))))
#+end_src

- Haven't yet mastered the mode-line.
#+begin_example emacs-lisp :tangle no
  ;;        `(mode-line ((,c :underline ,border-mode-line-active
  ;;                         :overline ,border-mode-line-active
  ;;                         :box (:line-width 10 :color ,bg-mode-line-active))))
  ;;        `(mode-line-inactive
  ;;          ((,c :underline ,border-mode-line-inactive
  ;;               :overline ,border-mode-line-inactive
  ;;               :box (:line-width 10 :color ,bg-mode-line-inactive))))
#+end_example

* Find files in project
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/projectile-find-file-all ()
    (interactive)
    (let ((projectile-git-command "git ls-files -zco"))
  (projectile-find-file)))
#+end_src

* Use corfu as completion
- as directed by corfu wiki
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/orderless-dispatch-flex-first (_pattern index _total)
    (and (eq index 0) 'orderless-flex))

  (defun pspmacs/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-super-capf
                       #'eglot-completion-at-point
                       #'tempel-expand
                       #'cape-file))))

  (defun pspmacs/ignore-elisp-keywords (cand)
    (or (not (keywordp cand))
        (eq (char-after (car completion-in-region--data)) ?:)))

  (defun pspmacs/setup-elisp ()
    (setq-local completion-at-point-functions
                `(,(cape-super-capf
                    (cape-capf-predicate
                     #'elisp-completion-at-point
                     #'pspmacs/ignore-elisp-keywords)
                    #'cape-dabbrev)
                  cape-file)
                cape-dabbrev-min-length 5))
#+end_src

* python venv for pytest
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/pytest-use-venv (orig-fun &rest args)
    (if-let ((python-pytest-executable (executable-find "pytest")))
        (apply orig-fun args)
      (apply orig-fun args)))
#+end_src

* Use ipython as python interpreter
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/prefer-interpreter-ipython ()
    "Use ipython as the python interpreter if available.

  This requires us to reset various regular expressions."
    (interactive)
    (when (executable-find "ipython")
      (setq python-shell-interpreter (executable-find "ipython")
            python-shell-interpreter-args "-i --simple-prompt --no-color-info"
            python-shell-prompt-regexp "In \\[[0-9]+\\]: "
            python-shell-prompt-block-regexp "\\.\\.\\.\\.: "
            python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
            python-shell-completion-setup-code
            "from IPython.core.completerlib import module_completion"
            python-shell-completion-string-code
            "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")))
#+end_src

* Yank file name to clipboard
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/yank-file-name ()
    "Yank file-name to clipboard

  Also, display file name in echo area"
    (interactive)
    (kill-new buffer-file-name)
    (message (format "Copied: %s" buffer-file-name)))
#+end_src

* wayland kill-ring
- [[https://www.emacswiki.org/emacs/CopyAndPaste][Wayland copy/paste]]
#+begin_src emacs-lisp :tangle func.el
  (defun wl-copy (text)
    "Copy to wayland clipboard.

  Copy TEXT to wayland wl-copy"
    (setq wl-copy-process (make-process :name "wl-copy"
                                        :buffer nil
                                        :command '("wl-copy" "-f" "-n")
                                        :connection-type 'pipe))
    (process-send-string wl-copy-process text)
    (process-send-eof wl-copy-process))

  (defun wl-paste ()
    "Paste from wayland clipboard."
    (if (and wl-copy-process (process-live-p wl-copy-process))
        nil ; should return nil if we're the current paste owner
      (shell-command-to-string "wl-paste -n | tr -d \r")))
#+end_src

* Org-paths
- pspmacs/org-path: base org path
- pspmacs/org-template-path: path to org setupfile templates
- pspmacs/org-journal-path: path to org journal
#+begin_src emacs-lisp :tangle vars.el
  (require 'pspmacs/xdg)
  (defcustom pspmacs/org-path
    (expand-file-name "org/" xdg/emacs-data-directory)
    "Org mode base"
    :group 'pspmacs
    :type '(string :tag "Org files base"))

  (defcustom pspmacs/org-template-path
    (expand-file-name "templates" pspmacs/org-path)
    "Org mode templates (setupfile)"
    :group 'pspmacs
    :type '(string :tag "Org templates"))

  (defcustom pspmacs/org-journal-path
    (expand-file-name "journal" pspmacs/org-path)
    "Journal entries."
    :group 'pspmacs
    :type '(string :tag "Org Journal"))
#+end_src

* Reference paths
- pspmacs/ref-paths: paths to bibliography
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/ref-paths
    `(,(expand-file-name "references/" xdg/emacs-data-directory))
    "Reference base paths"
    :group 'pspmacs
    :type '(list (string :tag "Base to references")))
#+end_src

* Org-publish alist
- For bulk exporting org-files to html
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/project-to-publish-alist
      (org-root html-root org-templates)
    "Set root locations for source ORG-ROOT and target HTML-ROOT

  to publish orgmode files to html."
    (interactive
     (let (org-root html-root org-templates)
       (setq org-root (read-directory-name
                       "ORG Directory:\t"
                       nil default-directory
                       ".*" nil))
       (setq html-root (read-directory-name
                        "HTML Directory:\t"
                        (expand-file-name "../html" org-root) nil
                        ".*" nil))
       (setq org-templates (read-directory-name
                            "Templates Directory:\t"
                            (expand-file-name "templates"
                                              pspmacs/org-template-path)
                            nil ".*" nil))
       (list org-root html-root org-templates)))

    (catch 'pspmacs/mk-tag
      (unless (file-directory-p html-root)
        (if (yes-or-no-p (format "%s doesn't exist. Create? " html-root))
            (make-directory html-root t)
          (throw 'pspmacs/mk-tag nil)))
      (setq org-publish-project-alist
            (list
             (list "org-notes"
                   :base-directory org-root
                   :base-extension "org"
                   :publishing-directory html-root
                   :recursive t
                   :publishing-function 'org-html-publish-to-html
                   :headline-levels 4
                   :auto-preamble t)
             (list "org-static"
                   :base-directory org-root
                   :base-extension
                   "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
                   :publishing-directory html-root
                   :recursive t
                   :publishing-function 'org-publish-attachment)
             (list "org-templates"
                   :base-directory org-templates
                   :base-extension
                   "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
                   :publishing-directory html-root
                   :recursive t
                   :publishing-function 'org-publish-attachment)
             (list "org" :components
                   '("org-notes" "org-static" "org-templates"))))))
           #+end_src
           
* Org-Links
** Insert clipboard contents as link
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/org-paste-as-link ()
    "Paste contents of clipboard as link."
    (interactive)
    (let* ((link-loc (current-kill 0))
           (desc (read-string "Description:\t" link-loc)))
      (org-insert-link nil link-loc desc)))
#+end_src

** Copy link at point
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/org-copy-link-at-point ()
    "Copy link if thing at point as link"
    (interactive)
    (let* ((context (org-element-context))
           (type (org-element-type context))
           )
      (when (eq type 'link)
        (kill-new (format "%s:%s"
                          (org-element-property :type context)
                          (org-element-property :path context))))))
#+end_src

* Use Emacs for mail
- Caution: this requires many dependencies:
  - Mu and its dependencies
  - mbsync (isync) and its dependencies
#+begin_src emacs-lisp :tangle vars.el
  (defcustom pspmacs/set-mailbox nil
    "Set Emacs Mailbox (Mu4e, mbsync)"
    :group 'pspmacs
    :type 'boolean)
#+end_src

* Org mode scratch buffer
With motivation from [[https://emacs.stackexchange.com/questions/16492/is-it-possible-to-create-an-org-mode-scratch-buffer][stackexchange accepted answer]]
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs/mode-scratch (&optional buffer-mode)
    "Create a scratch buffer with arbitrary major mode in BUFFER-MODE"
    (interactive)
    (let* ((buffer-mode (or buffer-mode 'lisp-interaction-mode))
           (buffer-string-prefix (string-trim-right
                                  (if (symbolp buffer-mode)
                                      (symbol-name buffer-mode)
                                    buffer-mode)
                                  "-mode"))
           (scratch-name (format "*%s scratch*" buffer-string-prefix))
           (scratch-notice
            (format
             "%s%s\n%s mode.\n\n"
             "This buffer is for text that is not saved, and for "
             buffer-string-prefix
             "To create a file, visit it with C-x C-f and enter text in its buffer.")))
      (switch-to-buffer scratch-name)
      (with-current-buffer scratch-name
        (funcall-interactively buffer-mode)
        (when (= (buffer-size) 0)
          (insert scratch-notice)
          (beginning-of-buffer)
          (comment-line 2)
          (end-of-buffer)))))
#+end_src
* Org insert check-boxes and cookies
#+begin_src emacs-lisp :tangle func.el
  (defun pspmacs--org-pop-cookie (heading-cookie-re)
    "PRIVATE: used by `pspmacs/org-put-checkboxes'.

  HEADING-COOKIE-RE: regular expression that recognises cookies"
    (replace-regexp heading-cookie-re
                    ""
                    nil
                    (line-beginning-position)
                    (line-end-position)
                    t)
    (if (string= (org-get-todo-state) "TODO")
        (org-todo "")))

  (defun pspmacs--org-push-cookie ()
    "PRIVATE: used by `pspmacs/org-put-checkboxes'."
    (end-of-line)
    (insert " [/]")
    (unless (org-get-todo-state)
      (org-todo "TODO")))

  (defun pspmacs/org-map-plain-list (func)
    "Walk down the current heading to locate plain lists and map.

  Allpy FUNC to all lines which qualify to be list items `org-at-item-p'"
    (save-excursion
      (forward-line 1)
      (while (and (not (eobp))
                  (not (org-at-heading-p)))
        (when (org-at-item-p)
          (funcall func))
        (forward-line 1))))

  (defun pspmacs/org-put-checkboxes (&optional negate called-recursively)
    "Mark current line with incomplete tags.

  If current line is a heading, add a cookie '[/]' at the end.
  If current is a list, add a checkbox '[ ]' at the beginning.
  Pass otherwise or if already present.

  If NEGATE is t, perform the opposite action, removing checkboxes and cookes
  If CALLED-RECURSIVELY, don't update cookie statistics, that should be done
  only at the end of recursion by the caller function.
  "
    (interactive)
    (save-excursion
      (let
          ((line-text (buffer-substring-no-properties
                       (line-beginning-position)
                       (line-end-position)))
           (heading-cookie-re ".+\\(\\[[0-9]*/[0-9]*\\]\\)$"))
        (cond ((org-at-heading-p)
               ;; Handle Headings
               (if (string-match-p heading-cookie-re line-text)
                   (if negate
                       (pspmacs--org-pop-cookie heading-cookie-re))
                 (pspmacs--org-push-cookie))
               (unless called-recursively
                 (org-update-statistics-cookies t)))
              ((org-at-item-p)
               ;; Handle Lists
               (when (or (null (or (org-at-item-checkbox-p)
                                   negate))
                         (and (org-at-item-checkbox-p)
                              negate))
                 (org-toggle-checkbox '(4))))))))

  (defun pspmacs/org-put-checkboxes-recursively (&optional negate)
    "Mark current line with incomplete tags, iterating over org-subtree.

    Apply `pspmacs/org-put-checkboxes' recursively down the subtree;
    passing the optional argument NEGATE.
    "
    (interactive)
    (save-excursion
      (org-map-tree
       (lambda ()
         (pspmacs/org-put-checkboxes negate t)
         (org-map-entries
          (pspmacs/org-map-plain-list
           (lambda ()
             (pspmacs/org-put-checkboxes negate t)))
          nil
          'tree)))
      (org-update-statistics-cookies nil)))
#+end_src

* Footers
#+begin_src emacs-lisp :tangle vars.el
  ;;; vars.el ends there
#+end_src

#+begin_src emacs-lisp :tangle func.el
  ;;; func.el ends there
#+end_src

#+begin_src emacs-lisp :tangle pspack.el
  (load (expand-file-name "vars.el" (file-name-directory load-file-name))
        nil 'nomessage)
  (load (expand-file-name "func.el" (file-name-directory load-file-name))
        nil 'nomessage)
  (provide 'pspack)
#+end_src
